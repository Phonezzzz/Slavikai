# DevRules — правила разработки SlavikAI

Эти правила фиксируют требования, которые уже отражены в настройках проекта (`pyproject.toml`) и в текущей архитектуре (Agent/Tools/Sandbox/Memory).

## 1) Язык, типизация, стиль

- Язык проекта: Python 3.12 (`pyproject.toml` → `tool.ruff.target-version = py312`, `tool.mypy.python_version = 3.12`).
- Типизация: `mypy` в режиме `strict = true` (tests исключены через `exclude = [...]`).
- Форматирование и линт: `ruff` (линт + формат) — конфиг в `pyproject.toml`.
- TypeScript/JavaScript кода в репозитории нет. Правило “no any/as/optional-chaining без проверки” в этом проекте трактуется как:
  - **запрещено** “расплывать” типы через `Any`/`cast()` в доменной логике;
  - **запрещено** использовать `Optional[...]` без явной проверки на `None` (или без безопасного значения по умолчанию).

## 2) Никаких “silent-fallback”

- Любой fallback должен быть **явным**: либо с записью в `Tracer`/логгер (см. `core/tracer.py`), либо через понятную ошибку пользователю/в UI.
- Если функция возвращает “значение по умолчанию” из-за ошибки — это должно быть:
  - осознанно (и желательно проверено тестом),
  - наблюдаемо (лог/трейс), если влияет на поведение агента.

## 3) Инструменты: обязательный `ToolResult`

- Каждый инструмент обязан реализовать интерфейс `Tool.handle(self, request: ToolRequest) -> ToolResult` (см. `tools/protocols.py`).
- Ошибки инструмента возвращаются через `ToolResult.failure(...)`.
- Запрещено “проталкивать” исключения наружу как основной контроль потока; если исключение возможно — ловить и возвращать `ToolResult.failure(...)`.
- Конвенция проекта: если инструмент возвращает человекочитаемый текст, кладите его в `data["output"]`.

## 4) Sandbox restrictions (обязательные)

- Все операции с путями должны быть “заземлены” в песочнице:
  - общий sandbox: `sandbox/` (пример: `tools/filesystem_tool.py`, `tools/shell_tool.py`);
  - workspace: `sandbox/project/` (пример: `tools/workspace_tools.py`, `tools/project_tool.py`).
- Запрещены абсолютные пути и выход за пределы песочницы.
- Для нормализации/проверки пути используйте уже существующие хелперы конкретного инструмента:
  - `tools/filesystem_tool.py::_normalize_path(...)`;
  - `tools/workspace_tools.py::_ensure_in_workspace(...)`;
  - `tools/project_tool.py::_normalize_path(...)`.
- Общий хелпер для нормализации путей в песочнице существует в `shared/sandbox.py` (сейчас используется для `ShellTool.sandbox_root`).

## 5) Safe-mode (обязательный контур безопасности)

- Safe-mode реализован на уровне `ToolRegistry` и включается/выключается агентом (`core/agent.py` → `ToolRegistry.apply_safe_mode`).
- Инструменты, которые дают сетевой/системный доступ, должны быть выключаемыми safe-mode:
  - добавляйте имя инструмента в `SAFE_MODE_TOOLS_OFF` (см. `core/agent.py`);
  - обеспечьте тест, что инструмент реально блокируется.

## 6) Правила работы с LLM

- Сетевые вызовы к LLM должны быть изолированы в слое `llm/*` (см. `Brain` в `llm/brain_base.py`).
- Все LLM-клиенты обязаны:
  - иметь таймаут,
  - валидировать формат ответа (dict/list/choices/message/content),
  - выбрасывать понятные исключения вверх по стеку (агент уже обрабатывает и логирует ошибки).
- Не логировать секреты (API keys). Ключи берутся из env (`OPENROUTER_API_KEY`, `LOCAL_LLM_API_KEY` и т.п.) или из конфигов.

## 7) Где должны быть тесты

- Тесты лежат в `tests/`, именование: `test_*.py`.
- Запрещены реальные сетевые вызовы в тестах. Используйте стабы (пример: `tests/test_tts_stt_tools.py`, `tests/test_web_search_tool.py`).
- Тесты для индекса должны избегать загрузки real `sentence-transformers` модели (пример: monkeypatch `VectorIndex._get_model` в `tests/test_vector_index.py`).
- Для SQLite в тестах используйте `tmp_path`, не пишите в `memory/*.db`.

## 8) Минимальные требования качества (как сейчас настроено)

- `pytest` + `pytest-cov` с порогом покрытия **>= 80%** (см. `pyproject.toml` → `--cov-fail-under=80`).
- `ruff check .` — без предупреждений/ошибок.
- `ruff format --check .` — код должен быть отформатирован.
- `mypy .` — `strict` без ошибок (в текущей конфигурации tests исключены).

## 9) Репозиторий и артефакты

- В проекте есть runtime-артефакты (`logs/*`, `sandbox/*`, `memory/*.db`) и виртуальная среда. Новые артефакты такого рода **не добавлять** в git; вынос/очистка — отдельная задача (см. `updated_roadmap.md`).
- Если runtime-артефакт уже попал в индекс, удаляй его из индекса (`git rm --cached ...`) и фиксируй правило в `.gitignore`.
- Минимальный контроль перед PR: `git ls-files | rg '^(venv/|logs/|sandbox/|memory/.*\\.db$)'` должен возвращать 0 строк.

## 10) Git workflow (режим A)

- Работа начинается с `main`: `git checkout main`.
- На PR создаётся ветка: `git checkout -b pr-<номер>-<название>`.
- Перед любой работой в PR-ветке запускай `make git-check`.
- После завершения PR: `git rebase origin/main`, `git merge --ff-only <pr-branch>`, `git push origin main`.
- Перед финализацией изменений запускай `make check`.
- Нельзя продолжать новую фичу в старой ветке.
- После PR — всегда обратно на `main`.

## 11) Memory Companion: инварианты (policies-first, без auto-changes)

- **Запрещены** авто‑апдейты `Memory` в runtime (никаких “сам сохранил важное” без явного approve).
- **Запрещены** авто‑создание/изменение `PolicyRule` в runtime: правила появляются только как **Approved** после ручного review.
- Отсутствие фидбэка после ответа = `unknown` (это **не** `good` и не повод менять поведение).
- BatchReview запускается **только вручную** и генерирует только `PolicyRuleCandidate[]` (не правила).
- Trigger/Action для policies должны быть **типизированы** (никаких “dict на всё”): структуры обязаны валидироваться.
