# AGENT_MINIPROMPTS — план доделки Stage A/B/C (мини‑промпты)

Этот файл — “очередь задач” в формате мини‑промптов для агента/разработчика, который будет доводить проект до завершения **Stage A / Stage B / Stage C**.

Ограничения (факты по текущему репозиторию):
- Проект: Python 3.12 + PySide6, архитектура Agent/Planner/Executor/Tools/Memory/VectorIndex/UI/Workspace.
- Качество: ruff + mypy(strict) + pytest-cov (порог покрытия 80%) настроены в `pyproject.toml`.
- Тесты есть (см. `tests/*`), порог покрытия зафиксирован в `pyproject.toml` (`--cov-fail-under=80`).
- Safe-mode: блокирует `web/shell/project/tts/stt` (см. `core/agent.py`).
- Sandbox: есть для `fs` (`sandbox/`) и `workspace_*` (`sandbox/project/`).
- В репозитории сейчас **в git отслеживается `venv/` и runtime‑артефакты** (логи/БД/coverage) — это отдельная проблема репозитория.

Ниже — мини‑промпты (по смыслу это небольшие PR‑задачи). Каждый пункт содержит:
- **Цель**
- **Файлы**
- **Действия**
- **Критерии готовности**

---

## Stage A — ядро агента (довести до “production‑quality”)

### A0 — Базовая верификация перед правками
**Цель:** зафиксировать текущий baseline (тесты/линт/типизация) и способ запуска.
**Файлы:** `pyproject.toml`, `requirements.txt`, `tests/*`.
**Действия:**
- Запусти проверки качества так, чтобы они работали **без** привязки к закоммиченному `venv/`.
- Если локально нет `pytest/mypy/ruff`, установи зависимости из `requirements.txt` в отдельное окружение.
**Критерии готовности:**
- Есть воспроизводимая команда(ы) для `ruff`, `mypy`, `pytest` на “чистом” окружении.
- `pytest` проходит и покрытие `>=80%` сохраняется.

### A1 — Сделать `scripts/check.sh` устойчивым
**Цель:** “one‑shot” скрипт качества должен работать на свежем окружении и совпадать с `pyproject.toml`.
**Файлы:** `scripts/check.sh`.
**Действия:**
- Приведи команды к устойчивым формам: `python -m ruff ...`, `python -m mypy .`, `python -m pytest ...`, чтобы не зависеть от PATH/entrypoints.
- Убедись, что скрипт реально проходит на свежем окружении.
**Критерии готовности:**
- `bash scripts/check.sh` завершается успешно на корректно установленном окружении.

### A2 — CI: сделать workflow реально используемым
**Цель:** включить CI как “источник правды” для качества.
**Файлы:** `.github/workflows/check.yml`, `scripts/check.sh`, `requirements.txt`.
**Действия:**
- Проверь, что `.github/workflows/check.yml` присутствует и **отслеживается git** (если нет — добавить в репозиторий).
- Убедись, что workflow использует рабочий `scripts/check.sh`.
**Критерии готовности:**
- В репозитории есть рабочий workflow, который запускается на push/PR и выполняет `scripts/check.sh`.

### A3 — Репозиторная гигиена: убрать `venv/` и runtime‑артефакты из git
**Цель:** репозиторий должен содержать исходники, а не окружение и бинарники.
**Файлы:** `.gitignore`, git‑индекс (история), возможно `.github/workflows/check.yml`.
**Действия:**
- Удали из git‑индекса `venv/` (при необходимости — через `git rm -r --cached venv`), оставив его как локальный артефакт.
- Аналогично: `.coverage`, `logs/*.log`, `memory/*.db`, `sandbox/*` (тестовые файлы/аудио) — не должны быть отслеживаемыми.
- Сверь с `.gitignore`: сейчас правила есть, но они не помогают, если файлы уже закоммичены.
**Критерии готовности:**
- `git ls-files | rg '^venv/'` возвращает 0 строк.
- Репозиторий не отслеживает `.coverage`, `logs/*.log`, `memory/*.db`, `sandbox/**/*.mp3|*.txt` и т.п.
- Проект после этого по‑прежнему запускается (создаёт sandbox/DB/logs на лету).

### A4 — Shell sandbox_root: запретить выход за пределы `sandbox/`
**Цель:** устранить возможность указать `ShellConfig.sandbox_root` вне песочницы.
**Файлы:** `tools/shell_tool.py`, `shared/sandbox.py`, `tests/test_shell_tool_edges.py` (или новый тест).
**Действия:**
- Ограничь `ShellConfig.sandbox_root` так, чтобы он нормализовался/валидировался относительно `SANDBOX_ROOT` (как минимум запрет абсолютных путей и `..`).
- Добавь тест: попытка задать `sandbox_root` как абсолютный путь должна возвращать `ToolResult.failure`.
**Критерии готовности:**
- Тест покрывает кейс выхода из песочницы.
- `tools/shell_tool.py` не создаёт директории вне `sandbox/`.

### A5 — Консистентность “default shell config”
**Цель:** shell‑tool должен работать предсказуемо даже если `config/shell_config.json` отсутствует.
**Файлы:** `tools/shell_tool.py`, `config/shell_config.py`, возможно `core/agent.py`.
**Действия:**
- Выбери один контракт:
  - либо `ShellTool` автоматически создаёт дефолтный конфиг в `config/shell_config.json` при первом вызове,
  - либо `ShellTool` использует дефолтный `ShellConfig()` без обязательного файла.
- Добавь тест(ы) под выбранный контракт.
**Критерии готовности:**
- Поведение не зависит от “случайного” наличия файла в рабочем дереве.

---

## Stage B — Workspace слой (довести до “удобно и безопасно”)

### B0 — Явно закрепить контракт workspace‑патчей
**Цель:** определить, что именно поддерживает `workspace_patch`.
**Файлы:** `tools/workspace_tools.py`, `ui/workspace_panel.py`, `tests/test_workspace_tools.py`.
**Действия:**
- Реши: `workspace_patch` остаётся **single‑file unified diff only** или расширяется до многофайлового формата.
- Если остаётся single‑file: обнови документацию/тексты UI (подсказки) и тесты так, чтобы это было очевидно.
**Критерии готовности:**
- Контракт не двусмысленный (в коде/тестах/документации).

### B1 — Интеграция индексации проекта в UI Workspace
**Цель:** сделать `project index` доступным из UI без ручных команд.
**Файлы:** `ui/workspace_panel.py`, `core/agent.py` (если нужно), `tools/project_tool.py`.
**Действия:**
- Добавь кнопку/действие “Index workspace” в `WorkspacePanel`, вызывающую инструмент `project` с `cmd=index` и базой `.` (что соответствует `sandbox/project`).
- Покажи результат пользователю (сколько проиндексировано/пропущено).
**Критерии готовности:**
- Индексация запускается из UI и не требует терминала.

### B2 — Планирование → Workspace tools (минимальный “сквозной” кейс)
**Цель:** чтобы Planner/Executor могли выполнять хотя бы один реальный workspace‑сценарий.
**Файлы:** `core/planner.py`, `core/executor.py`, `shared/plan_models.py`, `tests/*`.
**Действия:**
- Выбери небольшой, тестируемый кейс: например “прочитай файл из workspace и верни первые N строк” или “запиши файл в workspace”.
- Добавь новые операции в `shared/plan_models.py` (если решишь разрешить `workspace_*` как operation).
- Научить `Executor._execute_with_tools` обрабатывать эти операции (или обеспечить передачу `step.tool_request` из Planner).
- Покрыть тестом сквозной сценарий: `Planner.build_plan` → `Executor.run` → `workspace_*`.
**Критерии готовности:**
- Есть минимум один end‑to‑end тест, где план реально использует workspace‑инструмент.

### B3 — WorkspaceRun: безопасность и UX
**Цель:** сделать `workspace_run` безопаснее и полезнее.
**Файлы:** `tools/workspace_tools.py`, `tests/test_workspace_tools.py`.
**Действия (варианты):**
- Ограничить доступные импорты/среду исполнения (NOT IMPLEMENTED сейчас) — если это нужно, вводить постепенно и с тестами.
- Улучшить вывод: всегда возвращать `stdout/stderr/exit_code`, уже реализовано — убедиться, что UI корректно показывает.
**Критерии готовности:**
- Новые ограничения (если добавлены) покрыты тестами и не ломают базовый кейс.

---

## Stage C — Desktop UI/расширения (довести до “удобно и поддерживаемо”)

### C0 — UI: инструменты и safe-mode (согласовать реестр и панель)
**Цель:** UI должен отражать реально зарегистрированные инструменты.
**Файлы:** `ui/tools_panel.py`, `core/agent.py`.
**Действия:**
- Добавь переключатель `project` (сейчас его нет в `ToolsPanel`, но инструмент есть).
- Проверь, что safe-mode продолжает отключать `web/shell/project/tts/stt`.
**Критерии готовности:**
- В UI можно включать/выключать `project` так же, как остальные инструменты.

### C1 — UI smoke tests (минимум)
**Цель:** поймать поломки импортов/UI на ранней стадии.
**Файлы:** `tests/` (новый тест), возможно `ui/*`.
**Действия:**
- Добавь минимальный тест, который импортирует и создаёт ключевые виджеты (например `MainWindow`) без запуска event loop.
- Если в CI среде это не проходит из‑за Qt платформы — зафиксируй это как NOT IMPLEMENTED и добавь ручной QA чеклист вместо теста.
**Критерии готовности:**
- Либо тест работает в CI, либо есть явное “NOT IMPLEMENTED” + чеклист ручной проверки.

### C2 — UX: упростить компоновку панелей
**Цель:** улучшить читаемость UI (сейчас очень много панелей в одном `QSplitter`).
**Файлы:** `ui/main_window.py`.
**Действия (варианты):**
- Перевести часть панелей во вкладки (например: Observability / Memory / Workspace / Settings).
- Сохранить функциональность без удаления панелей.
**Критерии готовности:**
- UI остаётся функциональным, но становится управляемым (меньше горизонтального скролла/сжатия).

### C3 — Пакетирование приложения
**Цель:** сделать воспроизводимый способ собрать desktop‑приложение.
**Файлы:** (новые) скрипт/док, возможно `scripts/`.
**Действия:**
- Сейчас в проекте packaging **NOT IMPLEMENTED**. Выбери инструмент (PyInstaller/Qt deploy) и добавь минимальный “build how-to”.
- Не добавляй новый инструмент без фиксации в docs и без проверки на базовом запуске.
**Критерии готовности:**
- Есть документированная команда сборки и проверка запуска собранного артефакта (manual ok).

---

## “Definition of Done” для завершения всех Stage

Stage A завершён, если:
- `scripts/check.sh` рабочий и используется CI;
- репозиторий не содержит `venv/` и runtime‑артефактов в git;
- shell sandbox не позволяет выход за пределы `sandbox/`;
- документация (`PROJECT_OVERVIEW.md`, `DevRules.md`, `CONTRIBUTING.md`, `updated_roadmap.md`) актуальна.

Stage B завершён, если:
- workspace‑контракт зафиксирован и покрыт тестами;
- индексация `sandbox/project` доступна из UI;
- есть хотя бы один end‑to‑end план, который реально использует `workspace_*`.

Stage C завершён, если:
- UI отражает реальные инструменты (`project` в панели);
- есть минимум smoke‑проверка UI (или явный NOT IMPLEMENTED + manual QA);
- есть зафиксированный путь к пакетированию (или явный NOT IMPLEMENTED с планом).
